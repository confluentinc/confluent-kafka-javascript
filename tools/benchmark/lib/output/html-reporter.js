'use strict';

const fs = require('fs');
const path = require('path');

/**
 * HTML reporter that generates self-contained HTML reports with Chart.js visualizations.
 * Styled similar to librdkafka benchmark tool.
 */
class HtmlReporter {
    /**
     * Generate HTML report for benchmark results.
     * @param {string} outputDir
     * @param {string} filename
     * @param {Object} data - Full benchmark result data
     * @returns {Promise<void>}
     */
    static async write(outputDir, filename, data) {
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        const html = HtmlReporter.generateHtml(data);
        const filePath = path.join(outputDir, filename);
        fs.writeFileSync(filePath, html, 'utf8');
    }

    /**
     * Generate HTML content.
     * @param {Object} data
     * @returns {string}
     */
    static generateHtml(data) {
        const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 16) + ' UTC';
        const preset = data.config?.preset || 'custom';

        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Benchmark: ${preset}</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
${HtmlReporter.getCss()}
    </style>
</head>
<body>
    <h1>Kafka Benchmark Report</h1>
    <p class="meta">Generated ${timestamp}</p>

${HtmlReporter.generateCards(data)}

    <h2>Configuration</h2>
${HtmlReporter.generateConfigGrid(data)}

    <h2>Charts</h2>
${HtmlReporter.generateCharts(data)}

    <h2>Per-Run Results</h2>
${HtmlReporter.generatePerRunTable(data)}

${HtmlReporter.generateAggregatedTables(data)}

    <footer>
        Generated by confluent-kafka-javascript benchmark tool &mdash;
        <a href="https://github.com/confluentinc/confluent-kafka-javascript">github.com/confluentinc/confluent-kafka-javascript</a>
    </footer>
</body>
</html>`;
    }

    /**
     * Generate CSS styles.
     * @returns {string}
     */
    static getCss() {
        return `
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
           background: #f4f6f9; color: #2d3748; padding: 24px; }
    h1 { font-size: 1.6rem; font-weight: 700; margin-bottom: 4px; }
    h2 { font-size: 1.1rem; font-weight: 600; margin: 24px 0 10px;
         color: #4a5568; border-bottom: 2px solid #e2e8f0; padding-bottom: 4px; }
    .meta { font-size: 0.85rem; color: #718096; margin-bottom: 20px; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 12px;
             font-size: 0.78rem; font-weight: 600; }
    .badge-ok   { background: #c6f6d5; color: #276749; }
    .badge-fail { background: #fed7d7; color: #9b2c2c; }
    .badge-preset { background: #bee3f8; color: #2c5282; }
    .badge-mode { background: #e9d8fd; color: #553c9a; }
    .cards { display: flex; gap: 16px; flex-wrap: wrap; margin-bottom: 24px; }
    .card { background: white; border-radius: 10px; padding: 16px 20px;
            box-shadow: 0 1px 4px rgba(0,0,0,.08); min-width: 150px; flex: 1; }
    .card-label { font-size: 0.75rem; color: #718096; text-transform: uppercase;
                  letter-spacing: .05em; margin-bottom: 4px; }
    .card-value { font-size: 1.4rem; font-weight: 700; }
    .card-value-sm { font-size: 1rem; }
    table { width: 100%; border-collapse: collapse; background: white;
            border-radius: 10px; overflow: hidden;
            box-shadow: 0 1px 4px rgba(0,0,0,.08); margin-bottom: 24px; }
    th { background: #2d3748; color: white; font-size: 0.78rem;
         text-align: left; padding: 10px 12px; font-weight: 600; }
    td { padding: 9px 12px; font-size: 0.84rem; border-bottom: 1px solid #edf2f7; }
    tr:last-child td { border-bottom: none; }
    tr:hover td { background: #f7fafc; }
    .run-ok td:first-child { border-left: 3px solid #48bb78; }
    .run-fail td:first-child { border-left: 3px solid #fc8181; }
    .na { color: #a0aec0; }
    .charts { display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
              margin-bottom: 24px; }
    .chart-box { background: white; border-radius: 10px; padding: 16px;
                 box-shadow: 0 1px 4px rgba(0,0,0,.08); }
    .chart-title { font-size: 0.85rem; font-weight: 600; color: #4a5568;
                   margin-bottom: 10px; }
    .config-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px,1fr));
                   gap: 10px; background: white; border-radius: 10px; padding: 16px;
                   box-shadow: 0 1px 4px rgba(0,0,0,.08); margin-bottom: 24px; }
    .config-item { font-size: 0.82rem; }
    .config-key { color: #718096; font-weight: 500; }
    .config-val { color: #2d3748; font-weight: 600; }
    .note-box { background: #c6f6d5; border-left: 4px solid #276749; padding: 10px 14px;
                border-radius: 6px; font-size: 0.83rem; margin-bottom: 20px; }
    footer { font-size: 0.75rem; color: #a0aec0; margin-top: 24px; text-align: center; }
    footer a { color: #718096; }
    @media (max-width: 700px) { .charts { grid-template-columns: 1fr; } }
`;
    }

    /**
     * Generate summary cards.
     * @param {Object} data
     * @returns {string}
     */
    static generateCards(data) {
        const config = data.config || {};
        const results = data.results || {};

        // Count successful/failed runs
        let totalRuns = 0;
        let successfulRuns = 0;
        for (const result of Object.values(results)) {
            if (result && result.total_runs) {
                totalRuns += result.total_runs;
                successfulRuns += result.successful_runs || 0;
            }
        }

        const runsBadge = successfulRuns === totalRuns
            ? `<span class="badge badge-ok">${successfulRuns} ok</span>`
            : `<span class="badge badge-fail">${successfulRuns}/${totalRuns}</span>`;

        // Get throughput if available
        const firstResult = Object.values(results)[0];
        const throughput = firstResult?.throughput_mbps?.mean?.toFixed(2) || 'N/A';

        return `
    <div class="cards">
      <div class="card">
        <div class="card-label">Preset</div>
        <div class="card-value"><span class="badge badge-preset">${config.preset || 'custom'}</span></div>
      </div>
      <div class="card">
        <div class="card-label">Mode</div>
        <div class="card-value"><span class="badge badge-mode">${config.mode || 'confluent'}</span></div>
      </div>
      <div class="card">
        <div class="card-label">Runs</div>
        <div class="card-value">${runsBadge}</div>
      </div>
      <div class="card">
        <div class="card-label">Broker</div>
        <div class="card-value card-value-sm">${config.brokers || 'localhost:9092'}</div>
      </div>
      <div class="card">
        <div class="card-label">Msg Size</div>
        <div class="card-value">${config.message?.size || 256} B</div>
      </div>
      <div class="card">
        <div class="card-label">Throughput</div>
        <div class="card-value">${throughput} MB/s</div>
      </div>
    </div>`;
    }

    /**
     * Generate configuration grid.
     * @param {Object} data
     * @returns {string}
     */
    static generateConfigGrid(data) {
        const config = data.config || {};
        const items = [];

        const addItem = (key, value) => {
            if (value !== undefined && value !== null) {
                items.push(`<div class="config-item"><span class="config-key">${key}</span>: <span class="config-val">${value}</span></div>`);
            }
        };

        addItem('message_count', config.stopping?.messageCount?.toLocaleString());
        addItem('message_size', config.message?.size ? `${config.message.size} B` : undefined);
        addItem('batch_size', config.producer?.batchSize?.toLocaleString());
        addItem('compression', config.producer?.compression || 'none');
        addItem('acks', config.producer?.acks || 'all');
        addItem('linger_ms', config.producer?.lingerMs);
        addItem('warmup_messages', config.producer?.warmupMessages?.toLocaleString());
        addItem('runs', config.runs);
        addItem('warmup_runs', config.warmupRuns);
        addItem('topic', config.topic);
        addItem('fetch_min_bytes', config.consumer?.fetchMinBytes);
        addItem('fetch_wait_max_ms', config.consumer?.fetchWaitMaxMs);

        return `    <div class="config-grid">${items.join('')}</div>`;
    }

    /**
     * Generate charts section.
     * @param {Object} data
     * @returns {string}
     */
    static generateCharts(data) {
        const results = data.results || {};
        const charts = [];
        let chartId = 0;

        // Throughput MB/s chart
        const types = Object.keys(results);
        if (types.length > 0) {
            const labels = [];
            const throughputs = [];
            const msgRates = [];

            for (const [type, result] of Object.entries(results)) {
                if (result?.individual_runs) {
                    result.individual_runs.forEach((run, i) => {
                        labels.push(`${type} R${i + 1}`);
                        throughputs.push(run.throughput_mbps?.toFixed(2) || 0);
                        msgRates.push(Math.round(run.messages_per_second) || 0);
                    });
                }
            }

            if (labels.length > 0) {
                charts.push(HtmlReporter.createChart(
                    `chart_${chartId++}`,
                    'Throughput — MB/s',
                    'bar',
                    labels,
                    [{ label: 'MB/s', data: throughputs, backgroundColor: 'rgba(54,162,235,0.75)' }]
                ));

                charts.push(HtmlReporter.createChart(
                    `chart_${chartId++}`,
                    'Throughput — msgs/s',
                    'bar',
                    labels,
                    [{ label: 'msgs/s', data: msgRates, backgroundColor: 'rgba(255,159,64,0.75)' }]
                ));
            }
        }

        // Latency chart if available
        const latencyResult = results.latency;
        if (latencyResult?.individual_runs) {
            const labels = latencyResult.individual_runs.map((_, i) => `Run ${i + 1}`);
            const avgLatencies = latencyResult.individual_runs.map(r => r.latency?.mean?.toFixed(2) || 0);
            const p95Latencies = latencyResult.individual_runs.map(r => r.latency?.p95?.toFixed(2) || 0);

            charts.push(HtmlReporter.createChart(
                `chart_${chartId++}`,
                'E2E Latency (ms)',
                'bar',
                labels,
                [
                    { label: 'avg (ms)', data: avgLatencies, backgroundColor: 'rgba(75,192,192,0.75)' },
                    { label: 'p95 (ms)', data: p95Latencies, backgroundColor: 'rgba(153,102,255,0.75)' }
                ]
            ));
        }

        // Resource usage chart
        const firstType = types[0];
        const firstResult = results[firstType];
        if (firstResult?.individual_runs) {
            const labels = firstResult.individual_runs.map((_, i) => `Run ${i + 1}`);
            const cpuData = firstResult.individual_runs.map(r => r.resources?.cpu_avg_pct?.toFixed(1) || 0);
            const memData = firstResult.individual_runs.map(r => r.resources?.mem_peak_mb?.toFixed(1) || 0);

            charts.push(HtmlReporter.createChart(
                `chart_${chartId++}`,
                'Resource Usage',
                'bar',
                labels,
                [
                    { label: 'CPU avg %', data: cpuData, backgroundColor: 'rgba(255,99,132,0.75)' },
                    { label: 'Mem peak MB', data: memData, backgroundColor: 'rgba(54,162,235,0.75)' }
                ]
            ));
        }

        return `    <div class="charts">\n${charts.join('\n')}\n    </div>`;
    }

    /**
     * Create a single chart HTML.
     */
    static createChart(id, title, type, labels, datasets) {
        return `
      <div class="chart-box">
        <div class="chart-title">${title}</div>
        <canvas id="${id}"></canvas>
        <script>
          new Chart(document.getElementById('${id}'), {
            type: '${type}',
            data: {
              labels: ${JSON.stringify(labels)},
              datasets: ${JSON.stringify(datasets)}
            },
            options: {
              responsive: true,
              plugins: { legend: { position: 'bottom' } },
              scales: { y: { beginAtZero: true } }
            }
          });
        </script>
      </div>`;
    }

    /**
     * Generate per-run results table.
     * @param {Object} data
     * @returns {string}
     */
    static generatePerRunTable(data) {
        const results = data.results || {};
        const rows = [];

        for (const [type, result] of Object.entries(results)) {
            if (!result?.individual_runs) continue;

            result.individual_runs.forEach((run, i) => {
                const status = run.error ? 'fail' : 'ok';
                const statusBadge = run.error
                    ? '<span class="badge badge-fail">FAIL</span>'
                    : '<span class="badge badge-ok">OK</span>';

                rows.push(`
        <tr class="run-${status}">
          <td>${type}</td>
          <td>${i + 1}</td>
          <td>${statusBadge}</td>
          <td>${run.messages?.toLocaleString() || '<span class="na">-</span>'}</td>
          <td>${run.throughput_mbps?.toFixed(2) || '<span class="na">-</span>'}</td>
          <td>${Math.round(run.messages_per_second)?.toLocaleString() || '<span class="na">-</span>'}</td>
          <td>${run.latency?.mean?.toFixed(2) || '<span class="na">-</span>'}</td>
          <td>${run.latency?.p95?.toFixed(2) || '<span class="na">-</span>'}</td>
          <td>${run.resources?.cpu_avg_pct?.toFixed(1) || '<span class="na">-</span>'}</td>
          <td>${run.resources?.mem_peak_mb?.toFixed(1) || '<span class="na">-</span>'}</td>
          <td>${run.duration_ms ? (run.duration_ms / 1000).toFixed(2) + 's' : '<span class="na">-</span>'}</td>
        </tr>`);
            });
        }

        return `
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Run</th>
          <th>Status</th>
          <th>Messages</th>
          <th>MB/s</th>
          <th>msgs/s</th>
          <th>Lat avg (ms)</th>
          <th>Lat p95 (ms)</th>
          <th>CPU avg %</th>
          <th>Mem peak MB</th>
          <th>Duration</th>
        </tr>
      </thead>
      <tbody>${rows.join('')}
      </tbody>
    </table>`;
    }

    /**
     * Generate aggregated statistics tables.
     * @param {Object} data
     * @returns {string}
     */
    static generateAggregatedTables(data) {
        const results = data.results || {};
        const tables = [];

        for (const [type, result] of Object.entries(results)) {
            if (!result?.throughput_mbps) continue;

            const rows = [];

            // Throughput rows
            if (result.throughput_mbps) {
                rows.push(HtmlReporter.createAggRow('MB/s', result.throughput_mbps));
            }
            if (result.messages_per_second) {
                rows.push(HtmlReporter.createAggRow('msgs/s', result.messages_per_second, true));
            }

            // Latency rows if available
            if (result.latency) {
                if (result.latency.mean) {
                    rows.push(HtmlReporter.createAggRow('Latency avg (ms)', result.latency.mean));
                }
                if (result.latency.p95) {
                    rows.push(HtmlReporter.createAggRow('Latency p95 (ms)', result.latency.p95));
                }
            }

            // Resource rows
            if (result.resources) {
                rows.push(`
        <tr><td>CPU avg (%)</td><td>${result.resources.cpu_avg_pct?.toFixed(1) || 0}</td><td>-</td><td>-</td><td>-</td><td>-</td></tr>`);
                rows.push(`
        <tr><td>CPU max (%)</td><td>${result.resources.cpu_max_pct?.toFixed(1) || 0}</td><td>-</td><td>-</td><td>-</td><td>-</td></tr>`);
                rows.push(`
        <tr><td>Mem avg (MB)</td><td>${result.resources.mem_avg_mb?.toFixed(1) || 0}</td><td>-</td><td>-</td><td>-</td><td>-</td></tr>`);
                rows.push(`
        <tr><td>Mem peak (MB)</td><td>${result.resources.mem_peak_mb?.toFixed(1) || 0}</td><td>-</td><td>-</td><td>-</td><td>-</td></tr>`);
            }

            // Run statistics
            rows.push(`
        <tr><td>Successful runs</td><td colspan="5">${result.successful_runs || 0} / ${result.total_runs || 0}</td></tr>`);

            tables.push(`
    <h2>${type.toUpperCase()} — Aggregated</h2>
    <table>
      <thead>
        <tr>
          <th>Metric</th><th>mean</th><th>stddev</th>
          <th>min</th><th>max</th><th>p50</th>
        </tr>
      </thead>
      <tbody>${rows.join('')}
      </tbody>
    </table>`);
        }

        // Add note about resource measurement
        if (tables.length > 0) {
            tables.unshift(`
    <div class="note-box">
      <strong>Note:</strong> CPU and memory are measured using Node.js process.cpuUsage() and process.memoryUsage() APIs.
      CPU % can exceed 100% on multi-core systems.
    </div>`);
        }

        return tables.join('\n');
    }

    /**
     * Create an aggregated statistics row.
     */
    static createAggRow(label, stats, isInteger = false) {
        const fmt = (v) => {
            if (v === undefined || v === null) return '-';
            return isInteger ? Math.round(v).toLocaleString() : v.toFixed(2);
        };

        return `
        <tr>
          <td>${label}</td>
          <td>${fmt(stats.mean)}</td>
          <td>${fmt(stats.stddev)}</td>
          <td>${fmt(stats.min)}</td>
          <td>${fmt(stats.max)}</td>
          <td>${fmt(stats.p50)}</td>
        </tr>`;
    }
}

module.exports = HtmlReporter;
